---
layout: post
title: RxJS学习
subtitle: RxJS学习笔记
categories: Angular
tags: [Angular,RxJS]
---

## Observables

1. **Observable:** represents the idea of an invokable collection of future values or events.

2. **Creating Observables:**

   * Observables can be created with`new Observable`. Most commonly, observables are created using creation functions, like`of`, `from`, `interval`, etc.

   * ```javascript
     import { Observable } from 'rxjs';
     
     const observable = new Observable(function subscribe(subscriber) {
       const id = setInterval(() => {
         subscriber.next('hi')
       }, 1000);
     });
     ```

   * ```javascript
     const observable = new Observable(subscriber => {
       const id = setInterval(() => {
           subscriber.next('hi')
       }, 1000);
     });
     ```

3. **Subscribing to Observables:**

   * Each call to `observable.subscribe` triggers its **own independent setup** for that given subscriber.
   
   * ```javascript
     observable.subscribe(x => console.log(x));
     ```
   
   * Observer不是注册给Observable的listener，Observable也不会记录注册到自己的Observer. A `subscribe` call is simply a way to start an "Observable execution" and deliver values or events to an Observer of that execution.
   
4. **Executing Observables:**

   * The code inside `new Observable(function subscribe(subscriber) {...})` represents an "Observable execution", a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.

   * There are three types of values an Observable Execution can deliver:
     - "Next" notification: sends a value such as a Number, a String, an Object, etc.
     - "Error" notification: sends a JavaScript Error or exception.
     - "Complete" notification: does not send a value.
     
   * ```javascript
     import { Observable } from 'rxjs';
     
     const observable = new Observable(function subscribe(subscriber) {
       try {
         subscriber.next(1);
         subscriber.next(2);
         subscriber.next(3);
         subscriber.complete();
       } catch (err) {
         subscriber.error(err); // delivers an error if it caught one
       }
     });
     ```

5. **Disposing Observable Executions:**

   * Since each execution is exclusive to** one Observer only**, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.
   
   * ```javascript
     import { from } from 'rxjs';
     
     const observable = from([10, 20, 30]);
     const subscription = observable.subscribe(x => console.log(x));
     // Later:
     subscription.unsubscribe();
     ```



## Observer

1. **Observer:** is a collection of callbacks that knows how to listen to values delivered by the Observable.

   ```javascript
   const observer = {
     next: x => console.log('Observer got a next value: ' + x),
     error: err => console.error('Observer got an error: ' + err),
     complete: () => console.log('Observer got a complete notification'),
   };
   
   observable.subscribe(observer);
   ```

2. ```javascript
   import { Observable } from 'rxjs';
   import { from } from 'rxjs';
   
   const observable = new Observable((subscriber) => {
     let count = 0;
     setInterval(() => {
       subscriber.next(count);
       count++;
     }, 1000);
   
     setTimeout(() => subscriber.complete(), 5000);
   });
   
   const observer = {
     next: (x) => console.log('Observer got a next value: ' + x),
     error: (err) => console.error('Observer got an error: ' + err),
     complete: () => console.log('Observer got a complete notification'),
   };
   
   const subscription = observable.subscribe(observer);
   ```



## Operators

1. **Pipeable Operators:**
   
   * Pipeable Operators are the kind that can be piped to Observables using the syntax `observableInstance.pipe(operator())`. 
   * These include, `filter(...)`, and `mergeMap(...)`. 
   * A Pipeable Operator is a function that takes **an Observable as its input** and **returns another Observable**. It is a pure operation: the previous Observable stays unmodified. Subscribing to the output Observable will also subscribe to the input Observable.
   
2. **Creation Operators:**

   * Can be called as standalone functions to create a new Observable.

   * `of(1, 2, 3)`creates an observable that will emit 1, 2, and 3, one right after another. 

   * ```javascript
     import { of, map } from 'rxjs';
     
     of(1, 2, 3)
       .pipe(map((x) => x * x))
       .subscribe((v) => console.log(`value: ${v}`));
     
     // Logs:
     // value: 1
     // value: 4
     // value: 9
     ```



## Subject

* An RxJS Subject is **a special type of Observable** that allows values to be multicasted to many Observers**. While plain Observables are **unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.

* Observer无法区分Observable execution来自unicast Observable还是Subject.

* Internally to the Subject, `subscribe` does not invoke a new execution that delivers values. 

* **注意：** Subject既是Observable也是Observer

  * 作为Observable，Subject可以subscribe Observer：

    ```javascript
    import { Subject } from 'rxjs';
    
    const subject = new Subject<number>();
    
    subject.subscribe({
      next: (v) => console.log(`observerA: ${v}`),
    });
    subject.subscribe({
      next: (v) => console.log(`observerB: ${v}`),
    });
    
    subject.next(1);
    subject.next(2);
    
    // Logs:
    // observerA: 1
    // observerB: 1
    // observerA: 2
    // observerB: 2
    ```

  * 作为Observer，Subject可以被Observable subscribe：

    ```javascript
    import { Subject, from } from 'rxjs';
    
    const subject = new Subject<number>();
    
    subject.subscribe({
      next: (v) => console.log(`observerA: ${v}`),
    });
    subject.subscribe({
      next: (v) => console.log(`observerB: ${v}`),
    });
    
    const observable = from([1, 2, 3]);
    
    observable.subscribe(subject); // You can subscribe providing a Subject
    
    // Logs:
    // observerA: 1
    // observerB: 1
    // observerA: 2
    // observerB: 2
    // observerA: 3
    // observerB: 3
    ```

    