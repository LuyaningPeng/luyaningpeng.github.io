---
layout: post
title: 第三章 时间、时钟和事件顺序
categories: Distributed-Systems
tags: [Distributed-Systems]
---

## 三、时间、时钟和事件顺序

我们从一个谜语开始本章的学习，谜底将在稍后揭晓。

> #### 一个侦探故事
>
> 英国时间2012年6月30日至7月1日夜间，全球多个在线服务和系统同时崩溃。
> 服务器锁定并停止响应。
> 一些航空公司在几个小时内无法处理任何预订或办理登机手续。
> 发生了什么？
>
> **Slide 42**

在本讲中，我们将研究分布式系统中时间的概念。我们已经看到，我们关于时序的假设构成了分布式算法所依赖的系统模型的关键部分。例如，基于超时的失效检测器需要测量时间以确定超时的标准。操作系统广泛依赖计时器和时间测量来安排任务、跟踪CPU使用情况以及许多其他目的。应用程序通常希望记录事件发生的时间和日期：例如，在调试分布式系统中的错误时，时间戳帮助我们重现在不同节点、在同一时间点附近发生的事情。所有这些都或多或少需要准确的时间测量。

> #### 分布式系统中的时钟和时间
>
> 分布式系统经常需要测量时间，例如：
>* 调度器、超时、失效检测器、重试计时器
>* 性能测量、统计、分析
>* 日志文件和数据库：记录事件发生的时间
>* 具有时间限制有效性（time-limited validity）的数据（例如缓存条目）
>* 确定跨多个节点的事件顺序
>
> 我们对时钟的两种类型进行区分：
>* **物理时钟：**计算经过的秒数
>* **逻辑时钟：**计数事件，例如已发送消息
>
> **注意**：数字电子设备中的时钟（振荡器）≠分布式系统中的时钟（时间戳的来源）
>
> **Slide43**

### 3.1 物理时钟

物理时钟（Physical clocks）以秒为单位测量时间。它们包括基于摆锤或类似机制的模拟/机械时钟，以及基于振动石英晶体的数字时钟。大多数手表、所有电脑和手机、显示时间的微波炉以及许多其他日常用品中都有石英钟。物理时钟有时也称为挂钟，即使它们不需要真的挂在墙上。

> #### 石英钟
> * 石英晶体经过激光调整以在特定频率下发生机械共振
> * 压电效应：机械力⇔电场
> * 振荡器电路以谐振频率产生信号
> * 计算周期数以测量经过的时间
>
> ![](../../../../assets/images/distributed-system/slide44-1.png)
>
> ![](../../../../assets/images/distributed-system/slide44-2.png)
>
> **Slide 44**

石英钟很便宜，但并不完全准确。由于制造缺陷，一些时钟比其他时钟运行得稍快。此外，振荡频率随温度而变化。典型的石英钟室温附近非常稳定，但明显的高温或低温就会使时钟变慢。时钟运行快或慢的速率称为漂移（drift）。

> #### 石英钟误差：漂移
> 
>* 一个时钟走得稍微快一点，另一个稍微慢一点
>* 以百万分率(parts per million，ppm)测量的漂移
>* $1 ppm$=1微秒/秒=86毫秒/天=32秒/年
>* 大多数计算机时钟的时钟漂移在约$50 ppm$以内
>
> ![](../../../../assets/images/distributed-system/slide45.png)
> 
> **Slide 45**

当需要更高的精度时，可以使用原子钟。这些时钟基于某些原子（例如铯或铷）的量子力学特性。事实上，国际单位制(SI)中的时间单位秒被定义为铯133原子特定共振频率的9,192,631,770个周期。

>#### 原子钟
>
>* Caesium-133共振频率≈$9 GHz$（“超精细跃迁”）
>* 将电子振荡器调谐到该谐振频率
>* 1秒=该信号的9,192,631,770个周期
>* 准确性≈ $1 / 10^{-14}$（300万年1秒）
>* 价格≈20,000英镑（存疑）（可以以≈1,000英镑的价格买到更便宜的铷钟）
>
> <img src="../../../../assets/images/distributed-system/slide46.png" alt="https://www.microsemi.com/product-directory/cesium-frequency-references/4115-5071a-cesium-primary-frequency-standard" style="zoom: 80%;" />
> 
>**Slide 46**

另一种获取时间的高精度方法是依靠GPS卫星定位系统，或类似的系统，如Galileo或GLONASS。这些系统的工作原理是让几颗卫星绕地球运行并以超高分辨率广播当前时间。接收器测量每颗卫星发送的信号到达所花费的时间，并使用这些时间来计算它们与每颗卫星的距离，从而计算它们的位置。通过将GPS接收器连接到计算机，可以获得精确到几分之一微秒的时钟，前提是接收器能够从卫星获得清晰的信号。在数据中心中，通常电磁干扰过多而无法获得良好的信号，因此GPS接收器需要在数据中心的屋顶上安装天线。

> #### GPS 作为时间源
>
>* 31 颗卫星，每颗都携带一个原子钟
>* 卫星广播当前时间和位置
>* 根据卫星和接收器之间的光速延迟计算位置
>* 对大气效应、相对论等修正。
>* 在数据中心，屋顶上需要天线
>                           
><img src="../../../../assets/images/distributed-system/slide47.png" alt="https://commons.wikimedia.org/wiki/File:Gps-atmospheric-efects.png" style="zoom:25%;" />
>
>**Slide 47**

基于原子钟（国际原子时，International Atomic Time，TAI）的时间测量系统运行良好，但它与我们基于日出和日落的日常时间感知脱节。行星地球绕其自转轴自转一圈并不需要铯133共振频率的24×60×60×9,192,631,770个周期。事实上，地球的自转速度甚至不是恒定的：它会因潮汐、地震、冰川融化和一些无法解释的因素影响而波动。我们现在有一个问题：有两种不同的时间定义——一种基于量子力学，另一种基于天文学——而这两种定义并不完全匹配。

解决方案是国际标准时间(Coordinated Universal Time，UTC)，它基于原子时，但一句地球自转变化进行了修正。在日常生活中，我们使用时区，时区为相对于UTC的偏移量。

英国的时区在冬天称为格林威治标准时间(GMT)，在夏天称为英国夏令时(BST)，其中GMT定义为等于UTC，而BST定义为UTC+1小时。令人困惑的是，GMT一词最初是指格林威治子午线上的平均太阳时，即它以前是用天文学来定义的，而现在是用原子钟来定义的。今天，术语UT1用于指代0°经度的平均太阳时。

> #### Coordinated Universal Time (UTC) 
>
> **格林威治标准时间**（GMT，solar time）：从格林威治子午线看，太阳在南方时为中午 **国际原子时**（TAI）：1天为24×60×60×9,192,631,770个caesium-133 的共振周期 
>
> **问题**：地球自转速度不是恒定的 
>
> **权衡**：UTC 是TAI 考虑地球自转后，经过校正的时间
>
> **时区**和**夏令时**是相对于 UTC 的偏移量
>
> <img src="../../../../assets/images/distributed-system/slide48.jpg" style="zoom: 25%;" />                            
>
> **Slide 48**

UTC和TAI之间的区别在于UTC包括闰秒（leap seconds），根据需要添加闰秒以使UTC与地球自转大致同步。

>#### 闰秒
>
>每年6月30日和12月31日23:59:59UTC，以下三种情况之一将会发生：
>
>* 时钟立即向前跳到00:00:00，跳过一秒（**负闰秒**）
>
>* 时钟像往常一样在一秒后移动到00:00:00
>
>* 时钟在一秒后移动到23:59:60，然后再过一秒后移动到00:00:00（**正闰秒**）
>
>具体选择会在提前几个月宣布。
>
><img src="../../../../assets/images/distributed-system/slide49.jpg" style="zoom: 50%;" />
>
>http://leapsecond.com/notes/leap-watch.htm
>
>**Slide 49**

由于闰秒的关系，并不是说一小时总是3600秒，一天总是86400秒。在 UTC 时标中，由于闰秒，一天的长度可以是 86,399 秒、86,400 秒或 86,401 秒。这使需要处理日期和时间的软件变得更加复杂。

>#### 计算机如何表示时间戳
>
>两种最常见的表示：
>* **Unix 时间**：自1970年1月1日00:00:00 UTC（“纪元”）以来的秒数，不包括闰秒
>
>* **ISO 8601**：年、月、日、小时、分钟、秒和相对于 UTC 的时区偏移
> 示例：2021-11-09T09:50:17+00:00
>
>两者之间的转换需要：
>
>* 公历：一年365天，闰年除外（year %4 == 0 && (year %100 != 0 || year %400 == 0)）
>* 意识到过去和未来的闰秒。 . . ？！
>
>**Slide 50**

在计算中，时间戳是特定时间点的表示。通常使用两种时间戳表示：Unix 时间和 ISO 8601。对于 Unix 时间，零对应于日期 1970年1月1日，称为纪元。有些地方会存在一些细微的变化：例如，Java 的 System.currentTimeMillis() 类似于 Unix 时间，但使用毫秒而不是秒。

为了确保正确性，使用时间戳的软件需要了解闰秒。例如，如果要计算两个时间戳之间经过了多少秒，则需要知道这两个日期之间插入了多少闰秒。但对于未来六个月以上的日期，这是不可能知道的，因为地球自转还没有发生！

软件中最常见的方法是简单地忽略闰秒，假装它们不存在，并希望问题以某种方式消失。 Unix 时间戳和 POSIX 标准采用了这种方法。对于只需要粗略计时的软件（例如四舍五入到最近的一天），这种方法是可以接受的，因为几秒的差异并不显着。

然而，操作系统和分布式系统通常确实依赖高精度的时间戳来准确测量时间，其中一秒的差异非常明显。在这样的设置中，忽略闰秒可能会造成严重后果。例如，假设您有一个 Java 程序正闰秒内（即当时钟显示23:59:60时）两次调用 System.currentTimeMillis()，相隔500 毫秒。这两个时间戳之差会是多少？它不会是500，因为 currentTimeMillis() 时钟不考虑闰秒。如果两个时间戳之间的差异为零，意味着时钟暂停了？或者差异甚至可能是负数，意味着时钟会倒转一小会儿？本文不会对此给出答案。（最好的解决方案可能是改用单调时钟，我们将在Slide 58中对此进行介绍。）

2012年6月30日闰秒处理不当导致当天许多服务同时失败（Slide 42）。由于 Linux 内核中的一个错误，闰秒在运行多线程进程时极有可能触发活锁条件 [Allen, 2013, Minar, 2012]。即使重新启动也不能解决问题，但设置系统时钟会重置内核中的错误状态。

> #### 多数软件是如何解决闰秒的？
>
> **无视他们！**
>
> 然而，OS 和 DistSys 通常需要亚秒级精度的计时。
>
> 2012 年 6 月 30 日：Linux 内核中的错误导致闰秒活锁，导致许多互联网服务中断
>
> 实际的解决方案：“涂抹”（smear，分散）一天中的闰秒
>
> <img src="../../../../assets/images/distributed-system/slide51.jpg" alt="https://www.flickr.com/photos/ru_boff/37915499055/in/photostream/" style="zoom:33%;" />
>
> **Slide 51**

如今，一些软件会明确处理闰秒，而其他程序选择继续忽略它们。现在广泛使用的实用解决方案是，当出现正闰秒时，不是将其插入23:59:59和00:00:00之间，而是故意将额外的秒分布在该时间前后的几个小时内，在此期间减慢时钟（或在负闰秒的情况下加快速度）。这种方法称为涂抹（smearing）闰秒，但它并非没有问题。==它是一个实用的替代方案，可以让所有软件都知道闰秒并使其保持稳健，而这很可能是不可行的。==

**练习 6**. *描述闰秒涂抹可能引起的一些问题。*

### 3.2 时钟同步和单调时钟

>#### 时钟同步
>计算机使用石英钟跟踪物理时间/UTC（带电池，断电时继续运行）
>
>由于**时钟漂移（clock drift）**，时钟误差逐渐增大
>
>**时钟偏移（clock skew）**：一个时间点上两个时钟之间的差异
>
>**解决方案**：定期从具有更准确时间源（原子钟或 GPS 接收器）的服务器获取当前时间
>
>协议：网络时间协议 (Network Time Protocol，NTP)，精确时间协议 (Precision Time Protocol，PTP)
>
>**Slide 52**

原子钟过于昂贵且体积庞大，无法内置于每台计算机和电话中，因此改用石英钟。由于时钟漂移的存在，需要时常对其进行调整（通常使用NTP）。所有主流操作系统都内置了 NTP 客户端。

> <img src="../../../../assets/images/distributed-system/slide53.png" style="zoom: 25%;" />
>
> **Slide 53**

> #### 网络时间协议 (NTP)
>
> 许多操作系统供应商运行 NTP 服务器，将操作系统配置为默认使用它们。
>
> 时钟服务器的层次结构排列成**层（strata）**：
>
> * Stratum 0: 原子钟或 GPS 接收器
>
> * Stratum 1：直接与 stratum 0 设备同步
>
> * Stratum 2：与 stratum 1 同步的服务器等。
>
> 可能联系多个服务器，丢弃异常值，平均休息
> 向同一台服务器发出多个请求，使用统计信息减少由于网络延迟变化引起的随机错误
> ==在良好的网络条件下将时钟偏差减少到几毫秒，但可能更糟！==

不可预测的延迟使得网络上的时间同步变得困难。正如Slide 36 中所讨论的，网络延迟和节点的处理速度可能会有很大差异。为了减少随机变化的影响，NTP 对时间测量进行了多次采样，并应用统计过滤器来消除异常值。

Slide 55 显示了 NTP 如何估计客户端和服务器之间的时钟偏差。当客户端发送请求消息时，它包含客户端时钟的当前时间戳 $t1$。服务器收到请求后，在处理请求之前，服务器根据服务器时钟记录当前时间戳 $t2$。当服务器发送响应时，它从请求中回显值 $t1$，并且还在回复中包含服务器的接收时间戳 $ t2 $ 和服务器的响应时间戳 $ t3$。 最后，客户端收到响应后，根据客户端时钟记录当前时间戳 $t4$。

我们可以通过从客户端的角度计算往返时间 $(t4 -t1)$ 并减去服务器上的处理时间 $(t3 - t2)$ 来确定消息在网络上传输所花费的时间。然后我们将单向网络延迟估计为总网络延迟的一半。因此，当响应到达客户端时，我们可以估计服务器的时钟将移至 $t3$ 加上单向网络延迟。然后我们从估计的服务器时间中减去客户端的当前时间 $t4$ 以获得两个时钟之间的估计偏差。

此估计取决于网络延迟在两个方向上大致相同的假设。如果延迟主要由客户端和服务器之间的地理距离决定，则此假设可能成立。然而，如果网络中的排队时间是延迟的一个重要因素（例如，如果一个节点的网络链路负载很重而另一个节点的链路有大量空闲容量），那么请求和响应延迟之间可能会有很大差异。不幸的是，大多数网络不会向节点提供任何关于特定数据包所经历的实际延迟的信息。

>#### 估计经过网络的时间
>
><img src="../../../../assets/images/distributed-system/slide55.png" style="zoom:50%;" />
>
>往返网络延迟：$\delta = (t4 − t1) − (t3 − t2)$
>客户端收到响应时的服务器预估时间：$t3 + \frac{\delta }{2} $
>估计的时钟偏移：$\theta = t3 + \delta 2 − t4 = t2 − t1 + t3 − t4$
>
>**Slide 55**

**练习 7**. *假设两个节点都正确遵循协议，NTP 客户端对一个特定服务器的时间偏移估计的最大可能误差是多少？*

一旦 NTP 估计了客户端和服务器之间的时钟偏移，下一步就是调整客户端的时钟以使其与服务器保持一致。用于此处的方法取决于偏移量。客户端通过调整时钟速度以根据需要稍微加快或减慢运行速度来温和地纠正微小差异，这会在几分钟内逐渐减少偏差。这个过程称为回转时钟（slewing the clock）。

Slide 57 显示了一个回转时钟的示例，其中客户端的时钟频率收敛到与服务器相同的速率，使两者在几毫秒内保持同步。当然，在特定系统中达到的精确度取决于客户端和服务器之间网络的时间属性。

但是，如果偏移较大，回转时间会过长，因此 NTP 客户端会根据服务器时间戳强制将其时钟设置为估计的正确时间。这称为步进时钟（stepping the clock）。任何正在查看客户端时钟的应用程序都会看到时间突然向前或向后跳跃。

最后，如果偏移非常大（默认情况下超过约 15 分钟），NTP 客户端可能会认为一定有问题，并拒绝调整时钟，将问题留给用户或管理员来纠正。出于这个原因，任何依赖时钟同步的系统都需要仔细监控时钟偏差：即使一个节点正在运行 NTP，但这并不能保证它的时钟是正确的，因为它可能会陷入恐慌状态（panic state）并拒绝调整时钟。

> #### 校正时间偏移
>
> 一旦客户端估计了时钟偏差 $\theta$，则它需要将该校正应用于其时钟。
>
> * 如果 $|\theta| < 125 ms$ ，**回转（slew）时**钟：稍微加快或减慢 500 ppm（使时钟在 ≈ 5 分钟内同步）
>
> * 如果 $125 ms ≤ |\theta| < 1,000s $ ，**步进（step）**时钟：将客户端时钟重置为估计的服务器时间戳
>
> * 如果 $|\theta|≥ 1,000s$ ，**恐慌（panic）**并什么都不做（将问题留给人工操作员解决）
>
> 依赖时钟同步的系统需要监控时钟偏移！
>
> **Slide 56**

> <img src="../../../../assets/images/distributed-system/slide57.png" alt="http://www.ntp.org/ntpfaq/NTP-s-algo.htm" style="zoom: 67%;" />
>
> **Slide 57**

事实上，时钟可能会被 NTP 步进，即突然向前或向后移动，这对任何需要测量经过时间的软件都有极大影响。Slide 58 展示了一个 Java 示例，其中我们想要测量函数 doSomething() 的运行时间。Java 有两个核心函数用于从操作系统的本地时钟获取当前时间戳：currentTimeMillis() 和 nanoTime()。除了不同的精度（毫秒与纳秒）之外，两者之间的主要区别在于它们在面对来自 NTP 或其他来源的时钟调整时的行为方式。

currentTimeMillis() 是日历钟（也称为实时时钟），它返回自固定参考点（在本例中为 1970 年 1 月 1 日的 Unix 纪元）以来经过的时间。当 NTP 客户端步进本地时钟时，时间时钟可能会跳跃。因此，如果您使用这样的时钟来测量经过的时间，则结束时间戳和开始时间戳之间的差值可能会比实际经过的时间大得多（如果时钟向前移动），甚至可能为负（如果时钟被后移了）。因此，这种类型的时钟不适合测量经过的时间。

另一方面，nanoTime() 是一个单调时钟，不受 NTP 步进的影响：它仍然计算经过的秒数，但它总是向前移动。NTP 转换只能调整它向前移动的速率。这使得单调时钟在测量经过的时间方面更加稳健。缺点是来自单调时钟的时间戳本身没有意义：它测量自某个任意参考点以来的时间，例如自这台计算机启动以来的时间。使用单调时钟时，只有来自同一节点的两个时间戳之间的差异才有意义。比较不同节点间的单调时钟时间戳是没有意义。

> #### 单调时钟和实时时钟
>
> ```java
> // 劣
> long startTime = System.currentTimeMillis();
> doSomething(); // NTP 客户端在此期间步进时钟
> long endTime = System.currentTimeMillis();
> long elapseMills = endTime - startTime;
> // elapseMills 可能是负的
> 
> // 优
> long startTime = System.nanoTime();
> doSomething();
> long endTime = System.nanoTime();
> long elapsedNanos = endTime - startTime;
> // elapseMills 总是大于等于0的
> ```
>
> **Slide 58**

大多数操作系统和编程语言都提供实时时钟和单调时钟，因为两者的用途不同。

> #### 单调时钟和实时时钟
>
> **实时时钟（Time-of-day clock）**：
>
> * 从固定日期开始的时间（例如 1970 年 1 月 1 日纪元）
> * 可能突然向前或向后移动（NTP 步进），受闰秒调整影响
> * 可以跨节点比较时间戳（如果同步）
> * Java: System.currentTimeMillis()
> * Linux: clock_gettime(CLOCK_REALTIME)
>
> **单调时钟（Monotonic clock）**：
>
> * 从任意点开始的时间（例如机器启动时）
> * 始终以接近恒定的速度向前移动
> * 适用于测量单个节点上经过的时间
> * Java: System.nanoTime()
> * Linux: clock_gettime(CLOCK_MONOTONIC)
>
> **Slide 59**

### 3.3 因果关系和happens-before原则

现在我们将继续讨论分布式系统中的事件排序问题，这与时间的概念密切相关。考虑Slide 60 中的场景，其中用户 A 发表声明 $m_1$ 并将其作为消息发送给其他两个用户 B 和 C。在收到 $m_1$ 后，用户 B 向其他两个用户 A 和 C发送回复 $m_2$ 。然而，即使我们假设网络链接是可靠的，它们也可能会重新排序（Slide 33），因此如果 $m_1$ 在网络中稍有延迟，C 可能会在 $m_1$ 之前收到 $m_2$。

从 C 的角度来看，结果令人困惑：C 首先看到回复 $m_2$，然后看到声明 $m_1$。在 C 看来，B 似乎能够预见未来，甚至在 A 说出来之前就预见到了 A 的声明。在现实生活中，这种打乱排序的情况不会发生，因此我们直觉上也不希望它在计算机系统中发生。

现考虑另一个示例，将 $m_1$ 视为在数据库中创建对象的指令，将 $m_2$ 视为更新该对象的指令。 如果节点在 $m_1$ 之前处理 $m_2$，它将首先尝试更新一个不存在的对象，然后创建一个不受 $m_2$ 控制的对象。数据库指令只有 $m_1$ 在 $m_2$ 之前处理时才有意义。

> #### 消息的顺序
>
> <img src="../../../../assets/images/distributed-system/slide60.png" style="zoom: 50%;" />
>
> $m_1$ = “用户A说： 月亮是奶酪做的！”
> $m_2$ = “用户B说： 不，不是这样的”
>
> 即使逻辑上 $m_1$ 发生在 $m_2$ 之前**（happened before）**，但用户C会首先看到 $m_2$， 之后才看到 $m_1$。
>
> **Slide 60**

C 如何确定消息放置的正确顺序？因为它的时间戳不可跨节点比较，所以单调时钟无法工作。首先尝试在用户想要发送消息时从实时时钟获取时间戳，并将该时间戳附加到消息中。 在这种情况下，我们可能理所当然地认为 $m_2$ 的时间戳比 $m_1$ 晚，因为 $m_2$ 是对 $m_1$ 的响应，因此 $m_2$ 一定发生在 $m_1$ 之后。

不幸的是，在部分同步的系统模型中，这并不是可靠的。由 NTP 和类似协议执行的时钟同步，总是会使得两个时钟之间的实际偏差具有不确定性，特别是如果两个方向上的网络延迟是不对称的。因此，我们不能排除以下情况：A 根据 A 的时钟发送时间戳为 $t1$ 的 $m_1$。 当 B 收到 $m_1$ 时，根据 B 的时钟，时间戳为 $t2$，其中 $t2 < t1$，因为 A 的时钟略早于 B 的时钟。 因此，如果我们根据时钟的时间戳对消息进行排序，我们可能会再次获得错误的顺序。

> #### 物理时间戳与因果关系不一致
>
> <img src="../../../../assets/images/distributed-system/slide61.png" style="zoom:50%;" />
>
> $m_1$ = （$t_1$，“用户A说： 月亮是奶酪做的！”）
> $m_2$ = （$t_2$，“用户B说： 不，不是这样的”）
>
> **问题**：即使使用同步时钟，$t2 < t1$ 也是可能的。时间戳顺序与预期顺序不一致！
>
> **Slide 61**

为了形式化我们在这种情况下的“正确”顺序的含义，我们使用Slide 62 中定义的 happens-before关系。此定义假设每个节点只有一个执行线程，因此对于一个节点上任何两个执行步骤，很清楚哪个先发生。更正式地说，我们假设在同一节点发生的事件有一个严格的总顺序（strict total order）。多线程进程可以通过使用单独的节点来表示每个线程的方式建模。

然后，我们定义消息发送总是在该消息接收之前，用以来扩展跨节点的顺序（换句话说，我们排除了时间旅行：不可能接收尚未发送的消息）。为方便起见，我们假设每条发送的消息都是唯一的，因此当收到一条消息时，我们总是可以明确地知道该消息是在何时何地发送的。在实践中，可能存在重复消息，但我们可以使它们唯一，例如通过在每条消息中包含发送方节点的 ID 和序列号。

最后，我们采用传递闭包，其结果为 happens-before 关系。这是一个偏序，意味着对于某些事件 a 和 b，可能既没有 a 发生在 b 之前，也没有 b 发生在 a 之前。 在这种情况下，我们称 a 和 b 为并发（concurrent）。请注意，这里的“并发”并不是字面上的“同时”，而是 a 和 b 是独立的，因为没有从一个到另一个的消息序列。

> #### happens-before 关系
>
> **事件（event）**是在一个节点上发生的事情（发送或接收消息，或本地执行步骤）。
>
> 我们说事件 $a$ 发生在事件 $b$ 之前（写作 $a → b$）当且仅当：
>
> * $a$ 和b出现在同一个节点，并且在该节点的本地执行顺序中 $a$ 出现在 $b$ 之前； 
> * 要么事件 $a$ 是一些消息 $m$ 的发送事件，事件 $b$ 是同一消息 $m$ 的接收事件（假设发送的消息是唯一的）；
> * 要么存在事件 $c$，使得 $a → c$ 和 $c → b$。
>
> happens-before 关系是一个偏序：$a → b$ 和 $b → a$ 都不满足是可能的。在这种情况下，a 和 b 是**并发的（concurrent）**（写作 $a \parallel b$）。
>
> **Slide 62**

> #### happens-before 关系示例
>
> <img src="../../../../assets/images/distributed-system/slide63.png" style="zoom: 50%;" />
>
> * 由于节点执行顺序，得出 $a \rightarrow b$，$c \rightarrow d$，$e \rightarrow f$
> * 由于消息 $m_1$和 $m_2$，得出 $b \rightarrow c$，$d \rightarrow f$
> * 由于传递性，得出 $a \rightarrow c$，$a \rightarrow d$，$a \rightarrow f$，$b \rightarrow c$，$c \rightarrow f$
> * $a \parallel  e$，$c \parallel  e$，$d \parallel  e$
>
> **Slide 63**

**练习8.** *如果关系 R 是非自反的 $(\nexists a. (a, a) \in R )$和传递的 $(\forall a,b,c. (a,b) \in R \wedge (b,c) \in R \Longrightarrow (a,c) \in R)$，则称关系R是严格偏序的（这两个性质也意味着 R 是不对称的，
即$\forall a,b (a, b) \in R \Longrightarrow (b, a) \notin R.)$。证明happens-before关系是严格偏序的。你可以假设任意两个节点之间的距离不为零，以及信息传播速度不能超过光速。*

**练习9.** 证明对于任意两个事件 $a$ 和 $b$，下面三种关系之一必定成立：$a \rightarrow b, b \rightarrow a, a \parallel b$

happens-before 关系是推理分布式系统中因果关系的一种方式。因果关系考虑信息是否可以从一个事件流向另一个事件，从而考虑一个事件是否可能影响另一个事件。在Slide 60 的示例中，$m_2$（“不，不是这样！”）是对 $m_1$（“月亮是奶酪做的！”）的回复，因此 $m_1$ 影响了 $m_2$。一个事件是否真的“导致”了另一个事件是我们现在不需要回答的哲学问题；对我们来说重要的是 $m_2$ 的发送者在发送 $m_2$ 时已经收到了 $m_1$。

> #### 因果关系
>
> 取自物理学（相对论）。
>
> * 当 $a \rightarrow b$ 时，则 $a$ 可能导致 $b$。
> * 当 $a \parallel b$ 时，我们知道 $a$ 不可能导致 $b$。
>
> happens-before 关系编码**潜在的因果关系（potential causality）**
>
> <img src="../../../../assets/images/distributed-system/slide64.png" style="zoom:50%;" />
>
> 令 $\prec$ 为事件的严格全序关系。
> 如果 $(a \rightarrow b) \Longrightarrow (a \prec b)$，则 $\prec$ 是因果顺序（或者：$\prec$ 是“符合因果关系”）
>
> **Slide 64**

因果关系的概念是从物理学中借用的，人们普遍认为信息的传播速度不可能超过光速。因此，如果您有两个事件 $a$ 和 $b$，它们在空间上相距足够远，但在时间上靠得很近，那么从 $a$ 发送的信号不可能在事件 $b$ 之前到达 $b$ 的位置，反之亦然。 所以，$a$ 和 $b$ 必须是因果无关（causally unrelated）的。

事件 $c$ 在空间上距离 $a$ 足够近，并且在时间上比 $a$ 足够迟，那么 $c$ 将在 a 的光锥内：也就是说，来自 $a$ 的信号有可能到达 $c$，因此 a 可能会影响 $c$。在分布式系统中，我们通常使用网络上的消息而不是光束，但原理非常相似。
