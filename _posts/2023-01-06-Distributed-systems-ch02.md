---
layout: post
title: 第二章 分布式系统模型
categories: Distributed-Systems
tags: [Distributed-Systems]
---

## 二、分布式系统模型

系统模型概括了我们对节点和网络行为方式的假设，是对其属性的抽象描述，在实践中可以通过各种技术实现。为了说明常见的系统模型，我们将从分布式系统中的两个经典思想实验开始本节：两个将军问题（the two generals problem）和拜占庭将军问题（the Byzantine generals problem）

### 2.1 两军问题

在两军问题[Gray,1978]中，我们想象两位将军，各自率领一支军队，他们想要攻占一座城市。城池防御坚固，若是两军中只有一个进攻，必将大军溃败。不过，如果两军同时进攻，便能顺利攻下城池。

>#### 两军问题
>
>![](../../../../assets/images/distributed-system/slide22.png)
>
>**Slide 22**

因此，两位将军需要协调他们的攻击计划。两军相距较远，只能靠使者来往，这使事情变得困难。使者必须经过城市控制的领土，因此有时会被俘虏。因此，一个将军发送的消息可能会或可能不会被另一位将军接收，并且发送者不知道他们的消息是否通过，除非收到对方的明确回复。如果一个将军没有收到任何消息，则无法判断这是因为另一个将军没有发送任何消息，还是因为所有信使都被俘虏了[^1 ]。

两位将军应该使用什么协议来商定计划？对于每位将军，有两种选择：要么将军承诺在任何情况下都会继续攻击（即使没有收到任何回应），要么将军在承诺攻击之前等待确认。在第一种情况下，承诺先行的将军冒着孤军作战的风险。在第二种情况下，等待确认的将军将问题转移给另一位将军，他现在必须决定是承诺攻击（并冒着孤身一人的风险）还是等待确认的确认。

>#### 两军问题
>
>![](../../../../assets/images/distributed-system/slide23.png)
>
>**Slide 23**

[^1 ]: 我不喜欢这种军国主义的比喻，但我们会坚持使用“两位将军”，因为这个问题在这个概念下众所周知。感谢Annette Bieniusa，以下另一种表述，：罗密欧和朱丽叶想在森林里秘密会面，需要商定日期。但如果他们中只有一个人到达了集合地点，他或她就会感到失望，悲剧就会发生。因此，他们必须在同一天去森林。不幸的是，他们通过鸽子进行交流的方式不是很可靠。鸽子经常分心、迷路或被射杀…

>#### 两位将军该如何决定？
>
>1. 将军1即使没有收到回复仍旧进攻？
>   * 派遣大量信使以增加越过战场的可能性
>   * 如果全部被俘，将军2不知道这次袭击，那么将军1就战败了。
>2. 将军1只有在收到将军2的进攻回应时才会攻击？
>   * 现在将军1是安全的
>   * 但是将军2知道将军1只有在将军2的收到回复时才会攻击
>   * 在将军2与问题1中将军1的情况相同
>
>**常识**：了解某事的唯一方法是交流
>
>**Slide 24**

 问题是无论交换多少信息，两位将军都无法确定另一方军队是否会一起进攻。重复的来回确认序列可以逐渐增强将军们达成一致的信心，但可以证明，他们无法通过交换任何有限数量的消息来得到百分百的确定。

这个思想实验表明，在分布式系统中，一个节点无法确定另一个节点的状态。节点如何知道某事的唯一方法是通过在消息中传达该问题。从哲学的角度来看，这可能类似于人与人之间的交流：我们没有心灵感应，所以让别人知道你在想什么的唯一方法是通过交流（通过语言、写作、肢体语言等）。

作为两军问题的一个实际例子，Slide 25将Slide 22中的模型应用到网上商店的商品支付应用中。商店和信用卡支付处理服务通过RPC进行通信，其中一些消息可能会丢失。但是，店铺要保证货到付款才发货，货到货了才从客户卡上扣款。

> #### 两军问题的应用
>
> ![](../../../../assets/images/distributed-system/slide25.png)
>
> **Slide 25**

实际上，网上购物的例子并不完全符合两军问题：在这种情况下，支付服务始终进行支付是安全的，因为如果商店最终无法发货，它可以退还货款。付款是可以撤销的（不像军队被打败）这一事实使问题可以解决。如果商店和支付服务之间的通信中断，商店可以等待连接恢复，然后查询支付服务以找出任何结果未知的交易状态。

### 2.2 拜占庭将军问题

拜占庭将军问题[Lamport等,1982]与两军问题具有相似的设定。同样，我们的目的是要占领一座城市，但是假定可能有三个或更多的军队。将军们再次通过信使进行交流，这次我们假设如果发送了一条消息，它总是会被正确传递。

> #### 拜占庭将军问题
>
> ![](../../../../assets/images/distributed-system/slide26.png)
> 
> **问题：**一部分将军可能是叛徒
> 
> **Slide 26**

拜占庭设定中的挑战在于，一些将军可能是“叛徒”：也就是说，他们可能会故意和恶意地误导和混淆其他将军。我们称叛徒是恶意的（malicious），而其他人是诚实的（honest）。Slide 27显示了此类恶意行为的一个示例：此处，将军3从将军1和将军2收到两条相互矛盾的消息。将军1告诉将军3进攻，而将军2声称将军1命令撤退。将军3无法确定将军2是否在说谎（第一种情况），或者将军2是否诚实而将军1正在发布自相矛盾的命令（第二种情况）。

> #### 可能撒谎的将军
>
> ![](../../../../assets/images/distributed-system/slide27.png)
>
> **Slide 27**

诚实的将军不知道谁是恶意的将军，但恶意的将军可能会勾结并暗中协商他们的行动。我们甚至可以假设所有恶意的将军都被邪恶的对手控制。拜占庭将军问题是确保所有诚实的将军都同意同一个计划（例如进攻还是撤退）。根据定义，不可能辨明的恶意将军将要做什么，所以我们能做的最好的事情就是让诚实的将军达成一致。

这很难：事实上，在一个具有恶意的将军和不可预测的通信延迟的系统中，可以证明只有严格少于三分之一的将军是恶意的情况下，才能解决拜占庭将军问题[Dwork等,1988,定理4.4]。换句话说，在一个有$3f+1$个将军的系统中，最多只能有$f$个可能是恶意的。例如，一个有4个将军的系统可以容忍$f=1$个恶意将军，一个有7个将军的系统可以容忍$f=2$个。

>#### 拜占庭将军问题
>
>* 每个将军要么是恶意的要么是诚实的
>* 最多有$f$个将军可能是恶意的
>* 诚实的将军不知道谁是恶意的
>* 心怀恶意的将军可能会串通一气
>* 然而，诚实的将军们必须就计划达成一致
>* 定理：如果存在$f$个恶意将军，那么至少需要$3f+1$个将军（即<1/3将军可能是恶意的）
>
>* 密码学（数字签名）帮助解决问题——但仍然很棘手

如果将军使用密码学（数字签名）来验证谁说了什么，问题就会变得更容易一些：例如，这将允许将军2向将军3证明将军1的命令是什么。我们不会在本课程中详细介绍数字签名，因为它们已在安全课程（Part IB Easter term）中介绍。然而，即使有签名，拜占庭将军问题仍然具有挑战性。

拜占庭将军问题是否具有实际意义？真正的分布式系统确实经常涉及复杂的信任关系。例如，客户需要相信网上商店会实际交付他们订购的商品，尽管如果商品未到货或收费过高，他们可以通过银行对付款提出异议。但是，如果一家网店以某种方式允许顾客在不付款的情况下订购商品，这个弱点无疑会被欺诈者利用，因此网店必须假设顾客可能是恶意的。另一方面，对于在同一数据中心运行的商店服务之间RPC而言，一个服务可以信任同一公司运行的其他服务。同时，由于有人可能会开设一家欺诈商店或使用窃取的信用卡号码，支付服务并不会完全信任商店，但相反商店可能确实信任支付服务。此类示例还有很多。最后，我们希望客户、在线商店和支付服务就所下的任何订单达成一致。拜占庭将军问题是对这种复杂信任关系的简化，但对于研究某些参与者可能有恶意行为的系统来说，它是一个很好的起点。

> #### 信任关系和恶意行为
>
> ![](../../../../assets/images/distributed-system/slide29.png)
>
> **Slide 29**

在分布式系统中，一些系统明确地应对了某些节点可能被恶意行为者控制的可能性，这种系统被称为拜占庭容错（Byzantine fault tolerant）。这种想法近年来在区块链和加密货币的背景下流行起来，目的在于即使系统的某些参与者正在尝试欺骗或破坏它，它仍将提供一定的保证。我们将在5.3节中重新讨论这个主题。

在我们继续之前，先简单地介绍一下“拜占庭”一词的起源。这个词来自拜占庭帝国，以其首都拜占庭或君士坦丁堡命名，也就是现在土耳其的伊斯坦布尔。没有历史证据表明拜占庭帝国的将军比其他地方的将军更容易搞阴谋诡计。相反，早在莱斯利·兰波特（Leslie Lamport）用“拜占庭”这个词来描述拜占庭将军问题之前，该词就已经有了“过于复杂、官僚、狡猾”的意义；确切的词源尚不清楚。

>#### 拜占庭帝国（公元650年）
>
>占庭/君士坦丁堡/伊斯坦布尔
>
><img src="../../../../assets/images/distributed-system/slide30.png" alt="https://commons.wikimedia.org/wiki/File:Byzantiumby650AD.svg" style="zoom: 25%;" /> 
>                   
>“拜占庭”长期以来一直被用于“过于复杂，官僚的，狡猾的”（例如“拜占庭税法”）
>
>**Slide 30**

### 2.3 描述节点和网络行为

在设计分布式算法时，系统模型旨在指导我们如何针对可能发生的错误作出假设。

>#### 系统模型
>
>上文介绍的两个思想实验：
>* 二位将军问题：一种网络模型
>* 拜占庭将军问题：一种节点行为模型
>在实际系统中，节点和网络都可能出现故障！
>
>捕获系统模型中的假设，包括：
>* 网络行为（例如消息丢失）
>
>* 节点行为（例如崩溃）
>
>* 时序行为（例如延迟）
>
>为每个部分选择模型。
>
>**Slide 31**

>网络不可靠
>
><img src="../../../../assets/images/distributed-system/slide32-1.png" style="zoom: 50%;" /> <img src="../../../../assets/images/distributed-system/slide32-2.png" style="zoom: 50%;" />
>
>海洋中，鲨鱼撕咬光缆
>
>https://slate.com/technology/2014/08/shark-attacks-threaten-google-s-undersea-internet-cables-video.html
>
>陆地上，奶牛踩踏电缆
>
>https://twitter.com/uhoelzle/status/1263333283107991558
>
>**Slide 32**

让我们从网络开始。没有网络是完全可靠的：即使在精心设计的具有冗余网络链接的系统中，也可能会出错[Bailis和Kingsbury，2014年]。有人可能不小心拔错了网线。鲨鱼和奶牛都被证明会对长途网络造成损害和中断（请参阅Slide 32上的链接）。或者网络可能暂时过载，这可能是发生意外，也可能是由于拒绝服务攻击（a denial-of-service attack）。任何这些都可能导致消息丢失。

在系统模型中，我们采取更抽象的观点，这使我们免于担心鲨鱼和牛的细节。大多数分布式算法假设网络在一对节点之间提供双向消息传递，也称为点对点（point-to-point）或单播（unicast）通信。真实网络有时确实允许广播或多播通信（同时向许多接收者发送数据包，例如用于发现本地网络上的打印机），但从广义上讲，假设仅单播是当今互联网的一个很好的模型。在稍后第4讲中，我们将展示如何在单播通信之上实现广播。

然后我们可以选择这些链接可靠性的高低。大多数算法将以下三种选项之一作为前提假设，见Slide 33。

> #### 系统模型：网络行为
>
> 假设两个节点之间的双向点对点通信，具有以下之一的特点：
> * **可靠**（Reliable，完美）链接：
> 当且仅当消息被发送时，消息才会被接收。
> 消息可能会重新排序。
> * **公平损失**（Fair-loss）链接：
> 消息可能会丢失、重复或重新排序。
> 如果您不断重试，消息最终会通过。
> * **任意**（Arbitrary）链接（主动对手，an active adversary）：
> 恶意对手可能会干扰消息（窃听、修改、丢弃、欺骗、重播）。
>
> 可靠链接 --（重试+去重）--> 公平损失链接 --（TLS）--> 任意链接
>
> **网络分区**（Network partition）：一些链接在很长一段时间内丢弃/延迟所有消息
>
> **Slide 33**

有趣的是，可以将某些类型的链接转换为其他类型。例如，如果我们有一个公平损失链接，我们可以通过不断重传丢失的消息直到它们最终被接收，并通过在接收方过滤掉重复的消息，将它变成一个可靠链接。公平损失假设意味着任何网络分区（网络中断）只会持续有限的时间，而不是永远，因此我们可以保证每条消息最终都会被接收到。

当然，在网络分区期间发送的任何消息只有在中断修复后才能收到，这可能需要很长时间，但Slide33上的定义并没有说明网络延迟或等待时间。我们将在Slide35上讨论该问题。

我们在1.2节中简要讨论过的TCP协议在网络数据包级别执行这种重试和去重。但是，TCP通常配置有超时，因此它会在一定时间后（通常是一分钟左右）放弃并停止重试。为了克服持续时间超过此限制的网络分区，除了TCP提供的机制之外，还需要实现单独的重试和去重机制。

**练习3**. *假设您有一个客户端-服务器RPC系统，其中客户端重复RPC请求，直到收到响应。服务器应该如何对请求进行去重？*

任意链接是Internet通信的准确模型：只要您的通信通过网络（无论是咖啡店wifi还是Internet主干网络）进行路由，该网络的运营商都可能以任意的方式会干扰和操纵您的网络数据包。操纵网络流量的人也被称为活跃的对手（an active adversary）。幸运的是，几乎可以使用密码技术将任意链接变成公平损失链接。传输层安全(Transport Layer Security，TLS)协议在https:// 中提供表示“安全”的“s”，可防止主动攻击者窃听、修改、欺骗或重放流量（有关更多信息，请参见安全课程，第IB部分Easter term）。

TLS唯一无法阻止的是对手丢弃（阻止）通信。因此，只有当我们假设对手不会永远阻止通信时，才能将任意链接转换为公平损失链接。在某些网络中，可能绕过中断的网络链接进行路由，但情况并非总是如此。

因此，可靠网络链接的假设可能并不像乍看起来那样不切实际：一般来说，只要我们在网络分区期间愿意等待一段任意的时间进行重传，那么所有发送的消息都有可能被接收。但是，我们还必须考虑消息发送方在尝试重传消息时崩溃的可能性，这可能导致该消息永久丢失。这就引出了节点崩溃的问题。

> #### 系统模型：节点行为
>
> 每个节点执行指定的算法，假设以下之一：
>* **崩溃-****停止（Crash-stop****）/****故障-****停止（fail-stop****）**：
> 如果在任何时刻节点崩溃（crashing），则该节点有故障（faulty）。崩溃后，它将永远停止执行。
>* **崩溃-****恢复（Crash-recovery****）/****故障-****回复（fail-recovery****）**：
> 节点可能随时崩溃，失去其内存状态。它可能会在稍后恢复执行。存储在磁盘上的数据在崩溃中幸存下来。
>* **拜占庭式（Byzantine****）/****故障-****任意（fail-arbitrary****）**：
> 如果节点偏离算法，则该节点有故障。故障节点可能会做任何事情，包括崩溃或恶意行为。
>
> 没有故障的节点称为**“正确（correct）”**
>
> **Slide 34**

在崩溃停止模型中，我们假设节点崩溃后，它永远不会恢复。对于不可恢复的硬件故障，或者当一个人把手机掉进马桶里，然后手机就永久失灵的情况，这是一个合理的模型。对于软件崩溃，崩溃停止模型就可能看起来不切实际，因为我们可以重启节点，之后它就会恢复。然而，一些算法采用崩溃停止模型，因为这使算法更简单。在这种情况下，崩溃并恢复的节点将不得不作为新节点重新加入系统。

崩溃恢复模型明确允许节点在崩溃后重新启动并恢复处理。当一个节点崩溃并重新启动时，我们假设它所有的内存状态都丢失了，但它在磁盘上持久存储的任何数据都被保留了下来。该模型没有设定崩溃节点恢复的时间长短，而且崩溃的节点有可能永远无法恢复。

最后，拜占庭模型是节点行为的最一般模型：与拜占庭将军问题一样，故障节点不仅可能崩溃，而且可能以任意方式偏离指定算法，包括表现出恶意行为。节点实现中的bug也可以归类为拜占庭故障。==然而，如果所有节点都运行相同的软件，它们都会有相同的bug，因此任何存在“拜占庭错误”（多于三分之一的错误节点）的算法都无法容忍这样的bug。==原则上，我们可以尝试使用同一算法的几种不同实现，但这并不是一个实用的选择。因此，我们通常使用术语“拜占庭”来指代故意偏离协议，而不是用术语bug。

对于网络，可以使用通用协议将一种模型转换为另一种模型。对于不同的节点行为模型，情况并非如此。例如，为崩溃恢复系统模型设计的算法可能与拜占庭算法完全不同。

> #### 系统模型：同步（时序）假设
>
> 假设网络和节点符合以下条件之一：
>* **同步（Synchronous****）：**
> 消息延迟不超过已知的上限。
> 节点以已知速度执行算法。
>* **部分同步（Partially synchronous****）：**
> 该系统在某些有限（但未知）的时间段内是异步的，其他时间段是同步的。
>* **异步（Asynchronous****）：**
> 消息可以任意延迟。
> 节点可以任意暂停执行。
> 完全没有时间保证。
>
> **注意：**计算机科学的其他领域以不同方式使用术语“同步”和“异步”。
>
> **Slide 35**

系统模型的第三部分是同步假设，它是关于时序的。我们在这里有三种选择，分别是同步、异步或部分同步[Dworketal, 1988]。

> 注意：令人困惑的是，这些术语在其他内容中也有不同的含义。例如，在RPC和I/O操作中，“同步”通常意味着“调用者阻塞/等待操作完成”，而“异步”意味着“调用者在发出请求后，不等待结果，继续执行”。虽然相同的词具有不同的含义，但由于这些术语在文献中被广泛使用，我们将坚持使用这些标准术语。

我们希望拥有一个同步系统：通过网络发送的消息永远不会超过某个已知的最大延迟，并且节点总是以可预测的速度执行它们的算法。如果存在上述系统，分布式计算中的许多问题就会容易得多。因为网络和节点在“大多数情况下”都表现良好，所以我们可以假设系统是同步的。

不幸的是，“大多数情况下”与“总是”不同，如果违反有限延迟和有限执行速度的假设（即使只是一小会儿），为同步模型设计的算法通常都会导致灾难性的错误，虽然这种情况很少发生。在实际系统中，网络延迟或执行速度有时差异很大的原因有很多，请参见Slide36。

另一个极端是异步模型，在这种模型中我们根本不对时间做出假设：我们允许消息在网络中任意延迟，允许节点处理速度有任意差异（例如，我们允许一个节点暂停执行，而其他节点继续正常运行）。为异步模型设计的算法通常非常稳健，因为它们不受任何临时网络中断或延迟峰值的影响。

不幸的是，分布式计算中的一些问题不可能在异步模型中解决，因此我们使用部分同步模型作为折中。在这个模型中，我们假设系统大部分时间是同步的并且表现良好，但偶尔它可能会转入异步模式，在这种模式下，我们不对时序做出任何保证，而且这种情况的发生是不可预测的。部分同步模型适用于许多实际系统，但正确使用它时仍需要小心。

> #### 实践中违反同步的情况
>
> 网络通常具有可预测的延迟，但延迟偶尔也会增加：
>* 消息丢失需要重试
>* 拥塞/竞争导致排队
>* 网络/路由重新配置
>
> 节点通常以可预测的速度执行代码，但偶尔也会暂停：
>* 操作系统调度问题，例如优先级倒置
>* STW（Stop-the-world）垃圾回收导致的暂停
>* 缺页错误、交换、抖动
>
> 尽管实时操作系统(RTOS)提供了调度保证，但大多数分布式系统不使用RTOS
>
> **Slide36**

系统可能违反同步假设的原因有很多。我们已经讨论过如果消息丢失并重新传输，延迟会无限制地增加，特别是我们必须等待网络分区修复结束才能传递消息。网络延迟增加的另一个原因是拥塞导致数据包在交换机缓冲区中排队。网络路由重新配置也可能导致较大的延迟：即使在单个数据中心内，也有数据包延迟超过一分钟的案例[Imbriaco，2012]。

我们期望节点执行算法的速度是恒定的：毕竟，一条指令通常需要固定数量的CPU时钟周期，并且时钟速度变化不大。然而，即使在单个节点上，运行中的程序也可能意外暂停很长时间，其原因有很多。操作系统中的调度可以抢占正在运行的线程并在其他程序运行时使其暂停，尤其是在负载较重的机器上。内存管理语言（如Java）同样存在问题，当垃圾回收时，它需要时不时地暂停所有正在运行的线程（这被称为stop-the-world垃圾回收暂停）。在较大的堆区中，这样的停顿可能长达几分钟[Thompson，2013]！缺页错误是线程可能被挂起的另一个原因，尤其是当没有剩余可用内存时。

正如您从本课程上半节的并发系统中了解到的那样，即使在程序中的任何地方，或在最不恰当的时刻，线程也可以会被抢占资源。尤其在分布式系统中，这个问题尤为需要重视，因为对于一个节点来说，时间在暂停时显得“静止（stand still）”，而在这段时间内所有其他节点继续正常执行它们的算法。这些节点甚至可能注意到该节点没有响应，并认为它已经崩溃。一段时间后，暂停的节点恢复处理，但并没有意识到它已经暂停了很长一段时间。

请注意，这些执行过程暂停与Slide34中讨论的崩溃和重启不同。当一个正在执行的进程或线程暂停时，它通常不会意识到它已被暂停，除非它定期检查系统时钟以测量经过的时间。然而重启是由程序显式控制的，因为它的内存状态会在崩溃期间丢失，但重启时它可能会从磁盘加载其固有状态。

结合可变网络延迟的诸多原因，这意味着在实际系统中，使用同步系统模型是很难保证安全的。大多数分布式算法需要针对异步或部分同步模型进行设计。

>#### 系统模型汇总
>
>对于以下三个部分中的每一个，选择一个模型：
>* **网络：**
> 可靠的、公平损失的或任意的
>* **节点：**
> 崩溃停止、崩溃恢复或拜占庭
>* **时序：**
> 同步、部分同步或异步
>
>这是任何分布式算法的基础。如果你的假设是错误的，那么所有努力都将白费！
>
>**Slide37**

### 2.4 容错和高可用性

正如Slide 4中强调的那样，构建分布式系统的一个原因是为了获得比单台计算机更高的可靠性。现在我们将根据已讨论过的系统模型对这个思想展开进一步探讨。

>#### 可用性
>
>在线商店想要24/7全天候销售商品！
>服务不可用=停机=赔钱
>
>可用性=正常运行时间=服务正常运行的时间
>* “两个九”=99%正常运行=停机3.7天/年
>* “三个九”=99.9%正常运行=停机8.8小时/年
>* “四个九”=99.99%正常运行=停机53分钟/年
>* “五个九”=99.999%正常运行=停机5.3分钟/年
>
>**服务级别目标(Service-Level Objective，SLO)：**
>例如“一天中99.9%的请求在200毫秒内得到响应”
>**服务级别协议(Service-Level Agreement，SLA)：**
>协定一些SLO，违规将进行处罚
>
>**Slide 38**

从商业角度来看，通常最重要的是服务的可用性。例如，一家网上商店希望能够在任何时间销售产品：网站的任何中断都意味着失去赚钱的机会。对于其他服务，甚至可能需要与客户签订合同协议，担保其可用性。如果服务失效，这也会损害服务提供商的声誉。

服务的可用性通常根据其在特定时间内正确响应请求的能力来衡量。服务是“可用”还是“不可用”的定义可能有些随意：例如，如果加载页面需要5秒，我们是否仍认为该网站可用？需要30秒呢？甚至需要一小时呢？

通常，服务的可用性期望用服务级别目标(SLO)来衡量，它通常指由特定客户端在特定时间段内测量的、在指定超时内需要返回正确响应请求的百分比。服务级别协议(SLA)是一种协议，它指定了一些SLO，以及不满足SLO的后果（例如，服务提供商可能需要向其客户提供退款）。

故障（例如节点崩溃或网络中断）是导致服务不可用的常见原因。为了提高可用性，我们可以降低故障频率，或者我们可以将系统设计为在某些组件出现故障的情况下继续工作；后一种方法称为容错（fault tolerance）。虽然通过购买更高质量的硬件和引入冗余可以降低故障频率，但这种方法永远无法将故障概率降低到零。相反，容错才是许多分布式系统采用的方法。

> #### 实现高可用性：容错
>
> **失效（Failure）**：系统整体不工作
>
> **故障（Fault）**：系统的某些部分不工作
>* 节点故障：崩溃（crash-stop/crash-recovery），算法偏离（拜占庭）
>* 网络故障：丢弃或显著消息延迟
>
> **容错（Fault tolerance）：**尽管有故障（小于某个最大故障数），系统将作为一个整体继续工作，
>
> **单点失效（Single point of failure，SPOF）**：故障导致失效的节点/网络链路
>
> **Slide 39**

容错性总是相对于所能容忍的最大故障数而言的：例如，一些分布式算法能够在少于一半的节点崩溃的情况下继续工作，但如果超过一半的节点崩溃，它们则会停止。想要容忍无限数量的故障是没有意义的：如果所有节点都崩溃并且无法恢复，那么无论算法多么聪明，都无法完成任何工作。

在某些系统中，单个组件出现故障会导致整个系统中断。这样的组件称为单点故障(a single point of failure，SPOF)，容错系统通常会尽量避免出现任何SPOF。例如，Internet被设计为没有SPOF：没有任何一台服务器或路由器的破坏会导致整个Internet瘫痪（尽管某些组件的丢失，例如关键的洲际光纤链路，确实会导致明显的中断）。

容错的第一步是故障检测，这通常是通过失效检测器（failure detector）完成的。（“故障检测器（fault detector）”是一个更合乎逻辑的名称，但“失效检测器”是常规术语。）失效检测器通常检测崩溃故障。尽管在某些情况下“拜占庭问题”确实会留下可用于识别和排除恶意节点的证据，但“拜占庭错误”并不总是可检测的。

> #### 失效检测器
>
> **失效检测器：**
> 检测另一个节点是否有故障的算法
>
> **完美的失效检测器：**
> 当且仅当节点崩溃时才将其标记为故障节点
>
> **崩溃停止/****崩溃恢复的典型实现：**
> 发送消息，等待响应，如果在一段时间内没有回复，则将节点标记为崩溃节点
>
> **问题：**
> 无法区分崩溃的节点、暂时无响应的节点、消息丢失和消息延迟
>
> **Slide40**

在大多数情况下，失效检测器的工作原理是定期向其他节点发送消息，如果在预期时间内未收到响应，则将节点标记为崩溃节点。理想情况下，我们希望当且仅当节点确实崩溃时才发生超时（这称为完美失效检测器）。然而，两军问题告诉我们，这并不是检测崩溃的完全准确的方法，因为没有响应也可能是由于消息丢失或延迟造成的。

一个完美的、基于超时的失效检测器只存在于具有可靠链路的同步崩溃停止系统（asynchronous crash-stop system）中；在部分同步系统中，不存在完美的失效检测器。此外，在异步系统中，不存在基于超时的失效，因为超时在异步模型中没有意义。但是，部分同步系统中存在有用的失效检测器：最终完美的失效检测器（the eventually perfect failure detector）[Chandra和Toueg，1996]。

> #### 部分同步系统中的失效检测
>
> 完美的、基于超时的失效检测器只存在于具有可靠链路的同步崩溃停止系统中。
>
> **最终完美的失效检测器：**
>* 可能暂时将节点标记为崩溃的，即使该节点是正常的
>* 可能暂时将节点标记为正常的，即使它已经崩溃
>* 但最终，当且仅当节点崩溃时，将其标记为崩溃的
>
> 检测不是瞬时的结果，它有一定的延迟。
>
> **Slide 41**

稍后我们将看到如何使用这样的失效检测器来设计容错机制，并使节点自动从崩溃中恢复。使用此类算法可以构建具有高度可用性的系统。容忍崩溃也使日常操作更容易：==例如，如果一项服务可以容忍三个节点中的一个失效，则可以通过安装并重启一个节点的方式来进行软件更新，而其余的两个节点继续运行服务。==以这种方式进行软件升级，客户则不会注意到任何中断，这对于需要经常更新其软件的许多组织来说非常重要。

对于空中交通管制系统等安全关键型应用，良好的容错机制无疑是重要的。但是，并非总是可用性越高越好。达到极高的可用性需要高度集中的工程投入，并且通常需要选择较为保守的设计。例如，老式的固定电话网络是为“五个九”的可用性而设计的，但这种关注高可用性的设计有一个缺点，那就是它的发展非常缓慢。由于收益递减，大多数Internet服务甚至达不到“四个九”：一旦超出某个范围，获得更高可用性的额外成本将超过偶尔停机的成本，因此容忍一定数量的停机从经济角度看是合理的。

**练习4.** *可靠的网络链接允许消息重新排序。请给出一个算法的伪代码，该算法使用异步崩溃停止系统模型，它优化了可靠的点对点链接，使得消息按发送的顺序接收（这称为FIFO链接）。*

**练习5.** *如果改用崩溃恢复模型而不是崩溃停止模型，我们需要如何修改练习4中的算法？*
