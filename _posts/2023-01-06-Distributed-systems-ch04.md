---
layout: post
title: 第四章 广播协议和逻辑时间
categories: Distributed-Systems
tags: [Distributed-Systems]
---

## 四、广播协议和逻辑时间

本章我们将研究广播协议（也称为多播协议），即用于将一条消息传递给多个接收者的算法。正如我们将在第5讲中看到的那样，这些是高级分布式算法的实用组成部分。实际上有几种不同的广播协议，它们的主要区别在于它们传递消息的顺序。正如我们在上一章中看到的，排序的概念与时钟和时间密切相关。因此，我们将通过更仔细地研究时钟如何帮助我们跟踪分布式系统中的顺序来开始本讲。

### 4.1 逻辑时间

> #### 逻辑时钟 vs. 物理时钟
>
> * 物理时钟：计算经过的秒数
> * 逻辑时钟：计数发生的事件数
>
> 物理时间戳：对很多事情都有用，但可能与因果关系不一致。
>
> 逻辑时钟：旨在捕捉因果关系。
> $$
> (e_1 \rightarrow e_2) \Longrightarrow (T(e_1) < T(e_2))
> $$
>
> 我们将研究两种类型的逻辑时钟：
>
> * Lamport时钟（Lamport clocks）
> * 矢量时钟（Vector clocks）
>
> **Slide 65**

回想一下Slide  61，我们看到来自物理时钟的时间戳可能与因果关系不一致，即使这些时钟是使用NTP之类的东西同步的。也就是说，如果  **send($m$)**  是发送消息  $m$，happens‑before  关系表明  send($m_1$)  →  send($m_2$)，那么  send($m_1$)  的物理时间戳（根据$m_1$  的发送者的时钟）可能仍然小于send($m_2$)  的物理时间戳（根据$m_2$发送方的时钟）。

相反，逻辑时钟专注于正确捕获分布式系统中事件的顺序。我们将研究的第一种逻辑时钟是Lamport时钟，由Lamport  [1978]在分布式计算的一篇开创性论文中引入。

> #### Lamport 时钟算法
>
> **on** 初始化 **do**
> 	$ t := 0 $ // 每个节点都有自己的局部变量 $ t $
> **end on**
>	
> **on** 本地节点上任意事件发生 **do**
> 	$t := t + 1$
> **end on**
> 
> **on** 请求发送消息 $m$ **do**
> 	$t := t + 1; 通过底层网络链接 send($t, m$)
> end on
> 
> **on** 通过底层网络连接接受 $(t', m)$ **do**
> 	$t := max(t, t') + 1$
> 	将 $m$ 传递给应用程序
> **end on**
> 
> **Slide 66**

> #### Lamport 时钟的文字表达
>
> * 每个节点维护一个计数器  $t$，每个本地事件 $e$ 发生后递增
> * 令 $L(e)$ 为 $t$ 在递增之后的值
> * 将当前 $t$ 附加到通过网络发送的消息中
> * 接收方将其时钟向前移动到消息中的时间戳（如果大于本地计数器），然后递增
>
> 该方案的特性：
>
> * 如果 $a \rightarrow b$，则 $L(a) < L(b)$
> * 然而，$L(a) < L(b)$ 并不意味着 $a \rightarrow b$
> * 对于 $a \ne b$， 可能存在$L(a) < L(b)$
>
> **Slide 67**

Lamport  时间戳本质上是一个整数，用于计算已发生事件的数量。因此，它与物理时间没有直接关系。在每个节点上，时间都会增加，因为该整数会因为每个事件而递增。该算法采用崩溃停止模型（如果时间戳保存在稳定存储中，即在磁盘上，则采用崩溃恢复模型）。

当通过网络发送消息时，发送方将其当前的 Lamport 时间戳附加到该消息。在Slide 68 的示例中，$t = 2$ 附加到 $m_1$，$t  =  4$ 附加到 $m_2$。当接收者收到一条消息时，它将其本地  Lamport 时钟向前移动到消息中的时间戳加一；如果收件人的时钟已经在消息的时间
戳之前，则只会递增。

Lamport 时间戳具有这样的属性，即如果 $a$ 发生在 $b$ 之前，则 $b$ 总是具有比 $a$ 更大的时间戳；换句话说，时间戳与因果关系一致。然而，反之则不然：一般来说，如果 $b$ 的时间戳比 $a$ 大，我们就知道 $b \nrightarrow a$，但不知道是 $a \rightarrow b$还是 $a \parallel b$。

两个不同的事件也可能具有相同的时间戳。在Slide 68的示例中，节点A上的第三个事件和节点B上的第一个事件的时间戳均为 3。如果我们需要每个事件都有一个唯一的时间戳，则可以使用发生该事件的节点的名称或标识符扩展每个时间戳。在单个节点范围内，每个事件都分配一个唯一的时间戳；因此，假设每个节点都有一个唯一的名称，时间戳和节点名称的组合是全局唯一的（在所有节点中）。

> Lamport 时钟示例
>
> <img src="../../../../assets/images/distributed-system/slide68.png" style="zoom:50%;" />
>
> 令 $N(e)$ 为事件 $e$ 发生的节点。然后 $(L(e),  N(e))$ 唯一标识事件 $e$。
>
> 使用 Lamport 时间戳定义全序关系 $\prec$：
> $$
> (a \prec b) \Longleftrightarrow (L(a) < L(b) \vee (L(a) = L(b) \wedge N(a) < N(b)))
> $$
> 这个顺序是因果相关的：$ (a \rightarrow b) \Longrightarrow (a \prec b)$
>
> **Slide 68**

回想一下 happens‑before 关系是一个偏序（幻灯片62）。使用 Lamport 时间戳，我们可以将这个偏序扩展为全序。我们在 (timestamp,  node  name) 上使用字典顺序：也就是说，我们首先比较时间戳，如果它们相同，我们通过比较节点名称来决定顺序。

这种关系 $\prec$ 将所有事件置于线性顺序中：对于任意两个事件 $a \ne b$，我们有 $a \prec b$ 或 $b \prec a$。这是一个因果顺序：也就是说，只要 $a \rightarrow b$ 我们就有 $a \prec b$。换句话说，$\prec$ 是偏序 $\rightarrow$ 的线性扩展。但是，如果 $a \parallel b$ 我们可以有 $a \prec b$ 或 $b \prec a$，那么两个事件的顺序由算法任意确定。

**练习10.** 给定以下执行中的消息序列，请给出在每个发送或接收事件的 Lamport 时间戳。<img src="../../../../assets/images/distributed-system/exercise10.png" style="zoom:50%;" />

**练习11.**  使用 Lamport 时间戳证明全序 $\prec$ 是因果顺序。

给定两个事件的 Lamport 时间戳，通常无法判断这些事件是否同时发生，或者一个事件是否先于另一个事件发生。如果我们确实想检测事件何时并发，我们需要一种不同类型的逻辑时间：矢量时钟。

Lamport 时间戳只是一个整数（可能附有节点名称），而向量时间戳是一个整数列表，一个整数对应系统中的每个节点。按照惯例，如果我们将 $n$ 个节点放入向量 $\langle N_1,N_2, \dots ,N_n \rangle$，那么时间戳向量就是一个相似的向量$\langle t_1,  t_2, \dots , t_n \rangle$ 其中 $t_i$ 是对应于节点 $N_i$ 的条目。具体而言，$t_i$ 是在节点 $N_i$ 处发生的事件数。在向量 $T = \langle t_1,  t_2, \dots , t_n \rangle$ 我们将元素   为 $T[i]$，就像数组的索引一样。

> #### 矢量时钟
>
> 对于给定的 Lamport 时间戳 $L(a)$ 和 $L(b)$，其中 $L(a) < L(b)$，我们无法判断是 $a \rightarrow b$ 还是 $a \parallel b$。
>
> 如果我们想检测哪些事件是并发的，我们需要**向量时钟（vector clocks）**
>
> * 假设系统中有 $n$ 个节点，$N = \langle N_1,N_2, \dots ,N_n \rangle$
> * 事件 $a$ 的向量时间戳为 $V(a) = \langle t_1,  t_2, \dots , t_n \rangle$
> * $t_i$ 是节点 $N_i$ 观察到的事件数
> * 每个节点都有一个当前向量时间戳 $T$
> * 节点 $N_i$ 发生事件时， 向量元素 $T[i]$ 自增
> * 将当前向量时间戳附加到每条消息中
> * 接收者将消息向量合并到它的本地向量中
>
> **Slide 69**

除开标量和向量之间的区别，矢量时钟算法与 Lamport 时钟非常相似（比较Slide 66和Slide 70）。节点用0为每个系统中的节点初始化其向量时钟。每当节点 $N_i$ 发生事件时，它都会在其向量时钟中递增第 $i$ 个条目（它自己的条目）。（在实践中，这个向量通常被实现为从节点 ID 到整数的映射，而不是整数数组）。当通过网络发送消息时，发送者的当前向量时间戳附加到消息上。最后，当收到消息时，接收者通过取两个向量的元素最大值将消息中的向量时间戳与其本地时间戳合并，然后接收者递增自己的条目。

> #### 矢量时钟算法
>
> **on** 节点 $N_i$ 初始化  **do**
>	$ T := \langle 0, 0, \dots, 0 \rangle$ // 节点 $N_i$ 的局部变量
> **end on**
> 
> **on** 节点 $N_i$ 上发生任意事件 **do**
> 	$T[i] := T[i] + 1$
> **end on**
> 
> **on** 节点 $N_i$ 请求发送消息 $m$ **do**
> 	$T[i] := T[i] + 1$；通过网络发送 $(T, m)$
> **end on**
> 
> **on** 节点 $N_i$ 通过网络接收到 $(T', m)$ **do**
> 	对于每个 $j \in {1, \dots, n}$，执行 $T[j] := max(T[j], T'[j])$
> 	$T[i] := T[i] + 1$；传递 $m$ 给应用程序
> **end on**
> 
> **Slide 70**

Slide 71展示了该算法的实际应用示例。请注意，当 $C$ 从 $B$ 收到消息 $m_2$ 时，由于此事件对发生在 $A$ 的两个事件具有间接因果依赖性，所以$A$ 的向量条目也更新为2。这样，向量时间戳反映了 happens-before 关系的传递性。

> #### 矢量时钟示例
>
> 假定节点向量为 $N = \langle A, B, C \rangle$
>
> <img src="../../../../assets/images/distributed-system/slide71.png" style="zoom:50%;" />
>
> 一个事件 $e$ 的向量时间戳表示一组事件， $e$ 及其因果依赖：$\left\{ e \right \} \cup \left \{ a \mid a \rightarrow e \right \}$
>
> 比如，$\langle 2, 2, 0 \rangle$ 表示A发生前两个事件，B发生前两个事件和C未发生事件
>
> **Slide 71**

> #### 矢量时钟排序
>
> 定义向量时间戳的以下顺序（在具有 $n$ 个节点的系统中）：
>
> * $ T = T' \text{ iff } T[i] = T'[i] \text{ for all } i \in \left \{1, \dots, n \right \} $
>
> * $ T \leq T' \text{ iff } T[i] \leq T'[i] \text{ for all } i \in \left \{1, \dots, n \right \} $
>
> * $ T < T' \text{ iff } T \leq T' \text{ and } T \ne T' $
>
> * $ T \parallel T' \text{ iff } T \nleq T' \text{ and } T' \nleq T $
>
> $ V(a) \leq V(b) \text{ iff } (\left \{ a \right \} \cup \left \{ e \mid e \rightarrow a \right \} \subset ( \left \{ b \right \} \cup \left \{ e \mid e \rightarrow b \right \}$
>
> 此排序的性质：
>
> * $ (V(a) < V(b) \Longleftrightarrow (a \rightarrow b)) $
> * $ (V(a) = V(b) \Longleftrightarrow (a = b)) $
> * $ (V(a) \parallel V(b) \Longleftrightarrow (a \parallel b)) $
>
> **Slide 72**

然后我们定义向量时间戳的偏序，如Slide 72所示。如果第一个向量的每个元素都小于或等于第二个向量的对应元素，那么我们说该向量小于或等于另一个向量。如果一个向量小于或等于另一个向量，并且至少有一个元素不同，则它严格小于另一个向量。但是，如果一个向量中的某个元素具有更大的值，而另一个向量中的不同元素具有更大的值，则两个向量是不可比的。比如，$T = \langle 2, 2, 0 \rangle $和 $T' = \langle 0, 0, 1 \rangle$ 是不可比的，因为 $T[1] > T'[1]$ 但是 $T[3] < T'[3]$。

向量时间戳的偏序恰好对应于 happens‑before 关系定义的偏序。因此，矢量时钟算法为我们提供了一种在实践中计算 happens‑before 关系的机制。

**练习12.** *给定与练习10中相同的消息序列，请给出每个发送或接收事件的矢量时钟。*

**练习13.** *使用练习10和12中计算的 Lamport 和向量时间戳，说明是否可以确定以下事件具有happens-before 关系。*

|   Events    |   Events    | Lamport | Vector |
| :---------: | :---------: | :-----: | :----: |
| send($m_2$) | send($m_3$) |         |        |
| send($m_3$) | send($m_5$) |         |        |
| send($m_5$) | send($m_9$) |         |        |

练习  14.  *我们已经看到了几种类型的物理时钟（带 NTP 的时钟、单调时钟）和逻辑时钟。对于下列时间的每一种用途，辨析哪种时钟是最适用的：进程调度；输入/输出；分布式文件系统一致性；加密证书有效性；并发数据库更新。*

我们完成了对逻辑时间的讨论。我们已经看到了两种关键算法：Lamport 时钟和矢量时钟，一种提供全序，另一种捕获 happens‑before 的偏序。除此之外，还有其他各种结构：例如，结合了逻辑和物理时钟一些特性的混合时钟[Kulkarni 等人，2014年]。

### 4.2 广播协议中的传递顺序

许多网络提供点对点（单播）消息传递，即一条消息对应一个指定的接收者。我们现在将研究广播协议，它概括了网络，以便将消息发送到某个组中的所有节点。组成员可能是固定的，或者系统可以提供节点加入和离开组的机制。

某些局域网在硬件级别提供多播或广播（例如，IP 多播），但 Internet 上的通信通常只允许单播。此外，硬件级多播通常是在尽力原则（best-effort basis）上提供的，这允许丢弃消息；使其可靠则需要类似于此处讨论的重传协议。

关于节点行为（Slide 34）和同步（Slide 35）的系统模型假设直接适用于广播组。

> #### 广播协议
>
> 广播（多播）是群组通信：
>
> * 一个节点发送消息，组内所有节点交付消息
> * 一组组成员可以是固定的（静态的）或动态的
> * 如果一个节点出现故障，其余组成员继续传递
> * 注意：概念比 IP 多播更通用（我们建立在点对点消息传递之上）
>
> 建立在第 2 章的系统模型之上：
>
> * 可以是**尽力而为（best-effort）**，即可能会丢失消息；或**可靠的（reliable）**，即非故障节点通过重新传输丢失的消息来交付每条消息
> * 异步/部分同步时序模型 $\Longrightarrow$ 消息延迟**没有上限**
>
> **Slide 73**

> #### 接收（receiving）和交付（delivering）
>
> <img src="../../../../assets/images/distributed-system/slide74.png" style="zoom: 33%;" />
>
> 假设网络提供点对点发送/接收（send/receive）
>
> 在广播算法从网络接收消息后，节点可以在交付给应用程序之前对其进行缓冲/排队
>
> **Slide 74**

在讲解细节之前，我们应该澄清一些术语。当应用程序想要向组中的所有节点发送消息时，它使用一种算法来*广播（broadcast）*它。为了实现这一点，广播算法通过点对点链路向其他节点*发送（send）*一些消息，另一个节点*接收（receive）*通过点对点链路到达的消息。 最后，广播算法可以将消息*交付给（deliver）*应用程序。正如我们后文将会看到的，有时在收到消息和交付消息之间存在延迟。

我们将研究三种不同的广播形式。所有这些都是可靠的：每条消息最终都会传递到每个非故障节点，但没有时间保证。 然而，它们在每个节点上交付的顺序方面有所不同。事实证明，这种顺序差异对实现广播的算法具有非常根本的影响。

> #### 可靠广播的形式
>
> **FIFO广播**
> 如果 $m_1$ 和 $m_2$ 由同一个节点广播，且 $\text{broadcast}(m_1) \rightarrow \text{broadcast}(m_2)$，则 $m_1$ 必须在 $m_2$ 之前交付。
>
> **Causal广播**
> 如果 $\text{broadcast}(m_1) \rightarrow \text{broadcast}(m_2)$, 则 $m_1$ 必须在 $m_2$ 之前交付。
> 
> **全序广播**
> 如果在一个节点上，$m_1$ 在 $m_2$ 之前交付，则对于所有节点， $m_1$ 都必须在 $m_2$ 之前交付。
> 
> **FIFO全序广播**
> FIFO广播与全序广播的组合
> 
> **Slide 75**

最弱的广播类型称为**FIFO广播**，它与先进先出（FIFO）链接密切相关（见练习4）。在这个模型中，由同一节点发送的消息按其发送的顺序交付。例如，$m_1$ 必须在 $m_3$ 之前交付，因为它们都是由A发送的。然而，$m_2$ 可以在 $m_1$ 和 $m_3$ 之前、之间或之后的任何时间交付。

另一个细节是：每当一个节点广播一条消息时，它也会将该消息交付给自己（在Slide 76中表示为一个回环箭头）。这一点乍看没有必要，毕竟节点知道它自己广播了哪些消息，但在全序广播中是需要的。

> #### FIFO 广播
>
> <img src="../../../../assets/images/distributed-system/slide76.png" style="zoom: 33%;" />
>
> 同一节点发送的消息必须按照发送的顺序进行交付。
> 不同节点发送的消息可以按任意顺序交付。
> 有效顺序：($m_2$, $m_1$, $m_3$) 或 ($m_1$, $m_2$, $m_3$) 或 ($m_1$, $m_3$, $m_2$)

Slide 76 上的示例是有效的 FIFO 广播，但它违反了因果关系：节点 $C$ 在 $m_1$ 之前交付 $m_2$，即使 $B$ 在交付 $m_1$ 之后才广播 $m_2$。Causal广播提供了比 FIFO 广播更严格的排序属性。顾名思义，它确保消息按因果顺序传递：也就是说，如果一条消息的广播发生在另一条消息的广播之前，那么所有节点都必须按该顺序交付这两条消息。如果同时广播两条消息，则节点可以按任一顺序传送它们。

在Slide 76 的示例中，如果节点 $C$ 在 $m_1$ 之前接收到 $m_2$，则 $C$ 的广播算法将不得不阻止（延迟或缓冲）$m_2$，直到 $m_1$ 已交付，以确保消息按因果顺序交付。在Slide 77 的示例中，消息 $m_2$ 和 $m_3$ 同时广播。节点 $A$ 和 $C$ 按照 $m_1$、$m_3$、$m_2$的顺序交付消息，而节点 $B$ 按照$m_1$、$m_2$、$m_3$的顺序交付消息。这些交付顺序中的任何一个都是可以接受的，因为它们都符合因果关系。

> #### Causal广播
>
> <img src="../../../../assets/images/distributed-system/slide77.png" style="zoom:33%;" />
>
> 因果相关的消息必须按因果顺序传递。
> 并发消息可以按任何顺序传递。
> 这里：$\text{broadcast}(m_1) \rightarrow \text{broadcast}(m_2) \text{ and broadcast}(m_1) \rightarrow \text(broadcast(m_3)) \Longrightarrow $ 有效顺序是：（$m_1$，$m_2$，$m_3$）或（$m_1$，$m_3$，$m_2$）
>
> **Slide 77**

第三种广播是全序广播，有时也称为原子广播（atomic broadcast）。FIFO 和Causal广播允许不同的节点以不同的顺序交付消息，然而全序广播强制跨节点的一致性，确保所有节点以相同的顺序交付消息。没有定义精确的交付顺序，只要它在所有节点上都相同即可。

Slide 78 和 79 展示了两个全序广播的示例。在 Slide 78 上，三个节点都按照 $m_1$、$m_2$、$m_3$ 的顺序交付消息，而在 Slide 79 上，所有三个节点都按照 $m_1$、$m_3$、$m_2$ 的顺序交付消息。只要节点同意，任何一个顺序都是有效的。

与Causal广播一样，节点可能需要阻止消息，等待需要首先交付的其他消息。例如，节点 C 可以任意顺序接收消息 $m_2$ 和 $m_3$。如果算法已确定 $m_3$ 应在 $m_2$ 之前交付，但若节点 C 先接收到 $m_2$，则 C 将需要阻止 $m_2$ 直到接收到 $m_3$ 之后。

在这些图中可以看到另一个重要的细节：在 FIFO 和Causal广播的情况下，当一个节点广播消息时，它可以立即将该消息交付给自己，而无需等待与任何其他节点的通信。在全序广播中并非如此：例如，在Slide 78 中，$m_2$ 需要在 $m_3$ 之前交付，因此节点 A 向自身交付 $m_3$ 必须等到 A 从 B 收到 $m_2$ 之后。同样，在Slide 79 中， 节点 B 将 $m_2$ 传递给自己必须等待 $m_3$到来。

> #### 全序广播（1）
>
> <img src="../../../../assets/images/distributed-system/slide78.png" style="zoom:33%;" />
>
> 所有节点都必须遵从同样的顺序交付消息（在本处顺序为：$m_1$，$m_2$，$m_3$)
> 这包括了几个节点向自身交付信息！
>
> **Slide 78**

> #### 全序广播（2）
>
> <img src="../../../../assets/images/distributed-system/Slide79.png" style="zoom:33%;" />
>
> 所有节点都必须遵从同样的顺序交付消息（在本处顺序为：$m_1$，$m_3$，$m_2$)
> 这包括了几个节点向自身交付信息！
>
> **Slide 79**

最后，FIFO全序广播类似于全序广播，但是有额外的FIFO要求，即同一节点广播的任何消息都按照它们发送的顺序交付。Slide 78 和 79 上的示例是有效的FIFO全序广播，因为 $m_1$ 在 $m_3$ 之前交付。

> #### 广播模型之间的关系
>
> <img src="../../../../assets/images/distributed-system/slide80.png" style="zoom:33%;" />
>
> **Slide 80**

我们可以将这些不同的广播协议排列成一个层次结构，如Slide 80 所示。例如，FIFO 全序广播是一个比Causal广播严格更强健的模型；换句话说，每个有效的 FIFO全序广播协议也是一个有效的Causal广播协议（反之，不是），其他协议依此类推。

**习题 15. ** *证明Causal广播也满足 FIFO 广播的要求，和 FIFO 全序广播也满足Causal广播的要求。*

### 4.3 广播算法

我们现在将继续讨论实现广播的算法。粗略地说，这涉及两个步骤：首先，确保每条消息都被每个节点接收到；其次，以正确的顺序交付这些信息。我们将首先考虑可靠地传播消息。

我们可能尝试的第一个算法是：当一个节点想要广播一条消息时，它会使用Slide 33 中讨论的可靠链接（即重新传输丢失的消息）单独将该消息发送到每个其他节点。但是，可能会发生消息被丢弃的情况，和发送方在重新传输之前崩溃的情况。在这种情况下，其中一个节点将永远不会收到该消息。

> #### 广播算法
>
> 分为两个步骤：
> 1. 通过重传丢失的消息使尽力而为的广播可靠
> 2. 在可靠广播之上执行交付顺序
> 
> 首次尝试：广播节点直接向所有其他节点发送消息
> * 使用可靠链接（重传+去重）
> * 问题：节点可能在所有消息传递之前崩溃
> 
> **Slide 81**

为了提高可靠性，我们可以寻求其他节点的帮助。例如，我们可以在节点第一次收到特定消息时，会将其转发给所有其他节点（这称为Eager reliable广播）。该算法确保即使某些节点崩溃，所有剩余（非故障）节点也会收到每条消息。然而，该算法效率相当低：在没有故障的情况下，每条消息在一组 $n$ 个节点系统中发送 $O(n^2)$ 次，因为每个节点将收到每条消息 $n-1$ 次。这意味着该算法会耗费大量的冗余网络流量。

> #### Eager reliable广播
>
> 想法：节点**第一次**收到特定消息时，它会**重新广播**到其他节点（通过可靠链接）。
>
> <img src="../../../../assets/images/distributed-system/slide82.png" style="zoom:33%;" />
>
> 可靠，但是每条消息都被传输了$O(n^2)$次！
>
> **Slide 82**

已经开发了该算法的许多变体，在各个维度上进行了优化，例如容错、所有节点收到消息之前的时间以及使用的网络带宽。一个特别常见的广播算法系列是Gossip协议（也称为Epidemic协议）。在这些协议中，希望广播消息的节点将其发送给随机选择的少量固定数量的节点。在第一次收到消息时，节点将其转发给固定数量的随机选择的节点。这类似于八卦、谣言或传染病在人群中传播的方式。

Gossip协议并不严格保证所有节点都会收到消息：有可能在节点的随机选择中，某些节点总是被遗漏。但是，如果算法的参数选择得当，消息未被传递的概率会非常小。Gossip协议之所以吸引人，是因为在使用正确参数的情况下，它们对消息丢失具有很强的弹性，并且节点崩溃时也保持高效。

> #### Gossip协议
>
> 在向大量节点广播时很有用。
> 想法：当一个节点第一次收到消息时，将其转发给随机选择的其他 3 个节点。
>
> <img src="../../../../assets/images/distributed-system/slide83.png" style="zoom:33%;" />
>
> 实际上消息会抵达所有节点（大概率）
>
> **Slide 83**

现在我们有了可靠广播（使用Eager reliable广播或Gossip协议），我们可以在其上构建 FIFO、因果或全序广播。让我们从FIFO广播开始。

> #### FIFO广播算法
>
> **on** 初始化 **do**
> 	$sendSeq := 0; \ delivered := \langle 0, 0, \dots, 0 \rangle; \ buffer := \left \{ \right \}$
> **end on**
>
> **on** 节点 $N_i$ 请求广播 $m$ **do**
> 	通过可靠广播发送 $(i, sendSeq, m)$
> 	$sendSeq := sendSeq + 1$
> **end on**
>
> **on** 节点 $N_i$ 从可靠广播接收 $msg$ **do**
> 	$buffer := buffer \cup \left \{ msg \right \}$
> 	**while** $\exist sender, m. (sender, delivered[sender], m) \in buffer$ **do**
> 		交付 $m$ 给应用程序
> 		$delivered[sender] := delivered[sender] + 1$
> 	**end while**
> **end on**
>
> **Slide 84**

节点 $N_i$ 发送的每条FIFO广播消息都标有发送节点号 $i$ 和序列号，$N_i$ 发送的第一条消息序列号为 0，第二条消息为 1，依此类推。每个节点的本地状态包括序列号 $sendSeq$（统计该节点广播的消息数）、$delivered$（一个节点对应一个条目的向量，统计该节点已交付的来自每个发送者的消息数）和 $buffer$（一个缓冲区，用于保留消息，直到它们准备好被交付）。该算法检查来自任何发件人的消息是否与预期的下一个序列号匹配，然后递增该数字，确保来自每个特定发件人的消息按序列号递增的顺序交付。

Causal广播算法有点类似于FIFO广播；我们不是在广播的每条消息上附加一个序列号，而是附加一个整数向量。这种算法有时称为向量时钟算法，尽管它与 Slide 70 上的算法有很大不同。在 Slide 70的向量时钟算法中向量元素计算每个节点发生的事件数，而在Causal广播算法中，向量元素计算每个发送者已交付的消息数。

> #### Causal广播算法
>
> **on** 初始化 **do**
> 	$sendSeq := 0; \ delivered := \langle 0, 0, \dots, 0 \rangle; \ buffer := \left \{ \right \}$
> **end on**
>
> **on** 节点 $N_i$ 请求广播 $m$ **do**
> 	$deps := delivered; \ deps[i] := sendSeq$
> 	通过可靠广播发送 $(i, deps, m)$
> 	$sendSeq := sendSeq + 1$
> **end on**
>
> **on** 节点 $N_i$ 从可靠广播接收 $msg$ **do**
> 	$buffer := buffer \cup \left \{ msg \right \}$
> 	**while** $\exist (sender, deps, m) \in buffer. \ deps \leq delivered$ **do**
> 		交付 $m$ 给应用程序
> 		$buffer := buffer \backslash \left \{ (sender, deps, m) \right \}$
>		$delivered[sender] := delivered[sender] + 1$
> 	**end while**
> **end on**
>
> **Slide 85**

每个节点的本地状态由 $sendSeq$、$delivered$ 和 $buffer$ 组成，它们与 FIFO广播算法中的含义相同。当一个节点想要广播一条消息时，我们附加发送节点号 $i$ 和 $deps$，一个表示该消息的因果依赖关系的向量。我们通过获取 $delivered$ 的副本来构造 $deps$，该向量统计在该节点来自每个发送者的已交付的消息数量。这表明在该广播之前本地交付的所有消息必须按因果顺序出现在广播消息之前。然后，我们将此向量中发送节点对应的元素更新为 $sendSeq$，这可确保此节点广播的每条消息都与其广播的前一条消息具有因果关系。

当接收到消息时，算法首先像FIFO广播一样将其添加到缓冲区，然后在缓冲区中搜索所有准备好交付的消息。$deps \leq delivered$ 使用在Slide 72上定义的向量 $\leq$ 运算符。如果此节点已经交付了所有按因果顺序必定在此消息之前的消息，则此比较结果为真。任何因果就绪（causally ready）的消息随后会被交付到应用程序并从缓冲区中删除，并且 $delivered$ 向量的对应元素会递增。

> #### 全序广播算法
>
> **Single leader**方法：
>
> * 一个节点被指定为领导者
> * 要广播消息时，将消息发送给领导者；领导者通过FIFO广播算法进行广播。
> * 问题：leader 崩溃 $\Longrightarrow$ 不再有消息交付
> * 安全地更换领导者很困难
>
> **Lamport时钟**方法：
>
> * 将Lamport时间戳附加到每条消息
> * 按时间戳的全序交付消息
> * 问题：你怎么知道你是否看见了时间戳 $< T$ 的所有消息？需要使用 FIFO 链接并等待来自每个节点的时间戳 $\ge T$ 的消息

最后，全序广播（和 FIFO全序广播）更棘手。Slide 86 概述了两种简单的方法，一种基于指定的领导节点，另一种是使用 Lamport 时间戳的无领导算法。然而，这两种方法都不是容错的：在这两种情况下，单个节点的崩溃都会阻止所有其他节点交付消息。在Single leader方法中，领导者决定失效的节点。我们将在第 6 讲中回到容错全序广播的问题。

**练习16.**  *给出使用Lamport时钟实现FIFO全序广播的算法伪代码。您可以假设每个节点都有一个唯一的 ID，并且所有节点ID的集合是已知的。假设底层网络提供可靠的 FIFO 广播。*

